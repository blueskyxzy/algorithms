排序，查找，图和字符串
插入，选择，交换，打表，哈希
十大算法：
    1：归并排序，快速排序和堆排序
    2：傅立叶变换与快速傅立叶变换
    3：Dijkstra （迪杰斯特拉）算法（求最短路径）
    4：RSA算法（质数加密）
    5：安全哈希算法
    6：整数因式分解许多（加密协议（如RSA算法）都基于这样一个原理：对大的合数作因式分解是非常困难的。如果一个算法能够快速地对任意整数进行因式分解，RSA的公钥加密体系就会失去其安全性。）
    7：链接分析
    8：比例积分微分算法
    9：数据压缩算法
    10：随机数生成

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。

简述：
    插入排序：直接插入排序insertsort，希尔排序(又称缩小增量排序)shellsort，二分插入排序（又称折半插入排序），链表插入排序
    选择排序：直接选择排序selectsort，堆排序heapsort
    交换排序: 冒泡排序popsort，快速排序quicksort
    归并排序mergesort
    基数排序radixsort
    计数排序countsort
    桶排序bucketsort
    最短路径dijkstra

练习题：
    get24：求24



详细：
    插入排序：向已经有序的序列中依次插入值到适当位置，使其仍然有序
        直接插入排序：
            1：1轮遍历。1，2 ... n依次插入。    for i in range(1, len(arr))
            2：直接插入。从i与i-1比较，将小的交换到前面    while arr[i] < arr[i-1]       交换 i--
        二分插入排序：
            1：1轮遍历。
            2：折半插入。
        希尔排序：
            1: 按增量分组。增量(波长)d=len(arr)/2，d /=2，d>=1.   for i in range(d, len(x))
            2：直接插入。   while x[i-d] > k and i >= d   交换 i-=d

    选择排序：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完
        直接选择排序：
            1：2轮遍历。i从0到len-1,j从i到len-1，比较记录记录最小数的索引
            2：交换。将最小的与i交换位置
        堆排序：
            1：构建大顶堆(左右树都不大于于对应根节点的完全二叉树)+递归。大顶堆就是最大的数。 mid = (len - 1)/2。递归写某个节点构造大顶堆，初始化数据的时候将mid到0构造成大顶堆
            2：交换+遍历。i从大到小len-1到0,大顶堆数0与最后一个i交换位置。每次交换后再构建大顶堆。

    交换排序：通过比较将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。
        冒泡排序：
            1：2层循环。一般用2次for循环 0到len-1,len -1到i
            2：比较+交换。arr[j-1] > arr[j]，比较将最小的移到i
        快速排序：
            1：基准+2个索引。比基准小的排左边，小的排右边，二种方式：通过改变2个从两边到中间的左右索引和交换。通过2个从左到右的索引和交换的方式：(比low小1的索引)
            2：二分+递归。
    归并排序：2个序列合并成一个有序+递归
        1：递归。mid = (low + high)/2，从中间将序列分成多个2个序列
        2：2序列合并。将2个序列合并成一个有序序列。比较2序列最小的放到第三个序列(利用哨兵或者while),最初是长度是0或者1，都是有序的。



    最短路径dijkstra算法：以起始点为中心向外层层扩展，直到扩展到终点为止。（每次找到离源点最近的一个顶点，然后以该顶点为重心进行扩展）
        1:初始化。dis,T。dis记录顶点到各节点的当前的最短路径，T代表当前已经决定最短路径的顶点
        2:遍历。每一轮路径更新最短路径，直到更新全部路径
        3:确定一个顶点，返回2更新这个顶点的路径。确认顶点是dis中除了T中最小值那个顶点。







